+--------------------------+
| PROJECT 2: USER PROGRAMS |
|     DESIGN DOCUMENT      |
+--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

José de Jesús Vargas Muñoz <j.vargas.munoz@gmail.com>
Luis Alfredo Lizárraga Santos <siul.al4@gmail.com>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.



4.1. Cuestionario
=================

>> 1. Menciona al menos dos diferencias entre interrupciones internas y externas dentro de Pintos.
>>
>> Interrupciones internas: Ocasionadas por instrucciones del CPU.
>> Interrupciones externas: Se originan fuera del CPU.
>>
>> Interrupciones internas: Son síncronas, es decir, están sincronizadas con las instrucciones de CPU
>>	(ya que se originan ahí). La función intr_disable() no las desabilita.
>> Interrupciones externas: Son asíncronas, y pueden ser deshabilitadas con intr_disable().

>> 2. ¿Pueden suceder interrupciones anidadas? Si tu respuesta afirmativa menciona cuáles, si es nega-
>>    tiva explica por qué no.
>>
>> Es posible. Por ejemplo, los errores de paginación generados por accesos inválidos a memoria
>> de usuario.

>> 3. ¿Qué estrategia utiliza el Page Allocator de Pintos cuando le es requerida más de una página?
>>
>> Se tiene un mapa de bits para tener registro de las páginas disponibles a otorgar. Si al Page
>> Allocator le es solicitada más de una (n) página, busca en el bitmap n bits consecutivos cuyo valor sea 0;
>> lo cual indica que hay n páginas contiguas disponibles. Cambia los bits a uno indicando que ahora las
>> páginas están ocupadas. Ésta estrategia es conocida como "first fit".

>> 4. ¿Por qué es suceptible de fragmentación el Page Allocator de Pintos?
>>
>> Es posible que se tengan las n páginas requeridas disponibles, pero no necesariamente contiguas por
>> el hecho de que estén intercaladas entre páginas en uso.

>> 5. ¿Dentro de un programa podemos modificar directamente la memoria por medio de su dirección
>> física? Justifica tu respuesta.
>>
>> No es posible modificar directamente la memoria, el kernel le da a cada programa memoria virtual
>> para eliminar esta posibilidad, ya que el programa podría modificar espacios en memoria que no le corresponden
>> al programa y causar algún problema.

>> 6. ¿Qué información contiene el Page Table (Page Directory) de un proceso?
>>
>> En cada entrada contiene una dirección de memoria virtual y una dirección en la memoria principal
>> a la cual está mapeada la dirección de memoria virtual.

>> 7. Cierto o Falso: El espacio de Memoria Virtual de usuario es común para todos los procesos de
>> usuario, i.e. la una misma dirección en espacio de memoria virtual de usuario siempre contiene
>> la misma información para todos los procesos de usuario.
>>
>> Falso.



ARGUMENT PASSING
================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.
>>
>> thread.h, en struct thread
>>   #ifdef USERPROG
>>      char* process_name;
>>
>> Se añadió process_name para guardar el nombre del thread.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page (this is a very important issue)?
>>
>> La cadena de entrada se escribe al revés, y mientras es escrita, se llena
>> un arreglo de direcciones que indican el comienzo de cada argumento.
>> Por lo tanto, cuando deben ser escritos los valores argv[i] (las direcciones al
>> inicio de los argumentos), basta con recorrer el arreglo auxiliar creado.

---- RATIONALE ----

>> A3: Did you use strtok_r as part of your solution of Argument Passing? Why?
>>
>> No fue utlizada, porque no quisimos usar malloc para guardar los argumentos.
>> En su lugar, sustituimos primero los espacios en blanco de la cadena original
>> por caracteres de fin de cadena. De ésta forma, separamos en tokens la cadena
>> sin necesidad de descomponerla y reservar más memoria.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least some advantages of the Unix approach.
>>
>> 