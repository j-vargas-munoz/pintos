
+--------------------------+
|          CS 140          |
| PROJECT 2: USER PROGRAMS |
|      DESIGN DOCUMENT     |
+--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

José de Jesús Vargas Muñoz <j.vargas.munoz@gmail.com>
Ĺuis Alfredo Lizárraga Santos <siul.al4@gmail.com>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.


   	 SYSTEM CALLS
	 ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

>> thread.h
>>  #define MAX_FILES 128       Número de archivos posibles abiertos por proceso
>>
>>  struct file *executing;     Referencia al archivo que está ejecutando el thread
>>
>> 
>> syscall.c
>>  static struct lock file_lock;       Candado para resguardar las operaciones con archivos
>>
>>  static unsigned next_fd = 2;        El siguiente file descriptor a asignar
>>
>>  static struct file_node {           
>>   struct file* owned_file;           Referencia a un archivo abierto
>>   struct thread* owner_thread;       Referencia al thread que abrió el archivo
>>  };
>>
>>  static struct file_node *files[MAX_FILES];      Arreglo de file_node


>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

>> Se inicializa una variable next_fd en 2 (0 y 1 están reservados para IO) que se incrementa
>> cada vez que se abre un archivo.
>> Al archivo recién abierto, se le asigna como file descriptor el valor actual de next_fd, para
>> después incrementar la variable.
>> Los file descriptors son únicos dentro del SO.


---- ALGORITHMS ----

>> B3: Briefly describe how you solve requirement 3.3.5

>> Para cada thread se tiene un apuntador al archivo que está ejecutando.
>> Ésta referencia, llamada executing, se asigna en la función load; en la cual
>> también se niega el permiso de escritura al archivo que está ejecutando el thread.
>> Cuando el thread muere, se le otorgan permisos de escritura al archivo apuntado
>> por executing.

---- RATIONALE ----

>> B4: When a process is abroutely terminated, how do ensure all its asociated
>> resources are freed (files, locks, children list)? 

>> En thread_exit, libero la lista de hijos de cada thread. Y en syscall exit, cada vez
>> que un proceso termina se cierran los archivos que abrió.

>> B5: What advantages or disadvantages can you see to your design
>> for file descriptors?

>> Veo como ventaja que la búsqueda de archivos por su file_descriptor es constante,
>> ya que se tiene un arreglo de 128 localidades. Fue posible implementarse de ésta forma
>> porque se conocía de antemano el número máximo de archivos.
>> La desventaja es que si el número de archivos abiertos posibles es considerablemente
>> mayor, entonces reservar memoria contigua para un arreglo de referencias no es la mejor
>> opción. En éste caso, tal vez podría optarse por una tabla hash, para reducir tiempo
>> de búsqueda.


